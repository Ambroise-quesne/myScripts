#!/usr/bin/env python
# -*- coding=utf-8 -*-

"""
Manage VASP job operation and extract interesting data.

This script does not run the calculation. You have to check the input files
before !!

SYNTAX 
        v <sub-command> [OPTIONS]

SUB-COMMANDS

    get help
    --------
 
        -h, --hep, h, help
            print this help and exit.

    Manage calculations
    -------------------

        clean
            delete vasp output files

        restart
            copy necessary files for a restart calculation into a restart
            directory. None of the copied files are modified.

        sp
            copy the necessary files for an energy calculation into a 
            SinglePoint directory. In the new INCAR file, the following 
            keywords are changed:
                * NSW    -> NSW = 0
                * ISMEAR -> ISMEAR = -5
                * EDIFFG -> deleted
                * IBRION -> deleted
                * ISIF   -> deleted
                * LREAL  -> deleted
                * SIGMA  -> deleted

        spb
            Do the same things as sp but add keywords for a Bader calculation:
                * LAECHG = True
                * NGXF   = XXX
                * NGYF   = YYY
                * NGZF   = ZZZ

            The values of XXX, YYY and ZZZ are computed from lattice parameters
            assuming a distance between grid points of 0.03A.

    Extract data
    ------------

        cell [FILENAME]
            print lattice parameters calculated from [FILENAME]. [FILENAME]
            must be a POSCAR/CONTCAR file. If [FILENAME] is absent, a list of
            available POSCAR/CONTCAR files in the working directory is printed.

        cl [OPTIONS]
            Read core state eigenenergies from OUTCAR file (need pymatgen).

            v cl
                Read the INCAR file and output core state eigenergy of the AO
                of the atom define by CLNT, CLN and CLL keywords.

            v cl select
                Output all available core state eigenergies and ask for the
                atom index and the AO name of the core state.

            c cl [atom index] [atomic orbital]
                Output the core state eigenergies of the atom and the atomic
                orbital defined in the options. The first atom index is 1.
                [atomic orbital] is something like 1s, 2p, 3s ...

        tdos ['FILENAME', tofile]
            read DOS from 'vasprun.xml' or from 'FILENAME' and plot it using
            matplotlib (need pymatgen). 'FILENAME' must be a valid vasprun.xml
            file. 
            If tofile is present, the total DOS is printed into a file named
            'total_DOS.dat'.

        pdos ['FILENAME', tofile]
            read projected DOS from 'vasprun.xml' or from 'FILENAME' and plot
            it using matplotlib (need pymatgen). 'FILENAME' must be a valid 
            vasprun.xml file.
            If tofile is present, for each element, projected DOS are printed
            into a file named 'DOS_X.dat' where X is the symbol of the
            element.

    Compute data
    ------------

        chgsum [CHGCAR1] [CHGCAR2] [factor]
            Compute CHGCAR1 + factor * CHGCAR2 where CHGCAR are denisty file.
            This command needs pymatgen.

REMARK
        Job files are supposed to begin by 'j' or to have  a '.job' extension.

        Some functions may need pymatgen module (see http://www.pymatgen.org).
        
"""

from __future__ import division, print_function

import sys
import os
import shutil
import fnmatch

from math import sqrt, acos, pi, fabs, ceil

__author__ = "Germain Salvato-Vallverdu"
__email__ = "germain.vallverdu@univ-pau.fr"
__licence__ = "GPL"
__date__ = "June 2014"

options = ["h", "help", "-h", "--help",
           "clean", "sp", "spb", "restart",
           "cell", "cl", "chgsum",
           "tdos", "pdos"]

dashedLine = "".join(50 * ["-"])

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
# General functions
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

def _die(m="", code=0):
    """ print error and exit """
    print(m)
    exit(code)

def question(message):
    """ ask a question and read answer """
    answer = None
    while answer is None:
        a = raw_input(message + " (y/n) : ")
        if a.lower()[0] == "n":
            answer = False
        elif a.lower()[0] == "y" or a.lower()[0] == "o":
            answer = True
        else:
            print("hit 'y' for yes or 'n' for no")
    return answer

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
# Check and select functions
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

def check():
    """ check options """

    if len(sys.argv) < 2:
        _die("\nERROR, you must give a sub-command", 1)

    opt = sys.argv[1]
    if opt not in options:
        _die("\nERROR, option '%s' unknown" % opt, 1)

def select():
    """ select the operation to do """

    wd = os.getcwd()

    # help
    for opt in sys.argv:
        if opt in ["h", "help", "-h", "--help"]:
            _die(__doc__)

    # command name 
    opt = sys.argv[1].lower()

    if opt == "clean":
        cleanVasp()
    elif opt == "sp":
        makeSP()
    elif opt == "spb":
        makeSPBader()
    elif opt == "restart":
        makeRestart("restart")

    elif opt == "cell":
        # POSCAR file
        narg = len(sys.argv)
        if narg == 2:
            print(wd + ":")
            posfile  = fnmatch.filter(os.listdir(wd), "POSCAR*")
            posfile += fnmatch.filter(os.listdir(wd), "CONTCAR*")
            posfile += fnmatch.filter(os.listdir(wd), "*.vasp")
            for i, f in enumerate(posfile):
                print("    %3d -> %s" % (i, f))
            poscar = posfile[int(raw_input("\nfile number = "))]

        elif narg == 3:
            poscar = sys.argv[2]

        else:
            _die("Error, bad arguments.", 1)

        cell(poscar) 

    elif opt == "cl":
        coreLevel()
    elif opt == "chgsum":
        chgsum()

    elif opt == "tdos":
        tofile = False
        xmlfile = "vasprun.xml"

        if len(sys.argv) == 3:
            if sys.argv[2] == "tofile":
                tofile = True
            else:
                xmlfile = sys.argv[2]
        elif len(sys.argv) == 4:
            if sys.argv[2] == "tofile":
                xmlfile = sys.argv[3]
                tofile = True
            elif sys.argv[3] == "tofile":
                xmlfile = sys.argv[2]
                tofile = True
            else:
                _die("Error, bad arguments", 1)
        elif len(sys.argv) > 4:
            _die("Error, you gave too much arguments", 1)

        plot_total_dos(xmlfile, tofile)

    elif opt == "pdos":
        tofile = False
        xmlfile = "vasprun.xml"

        if len(sys.argv) == 3:
            if sys.argv[2] == "tofile":
                tofile = True
            else:
                xmlfile = sys.argv[2]
        elif len(sys.argv) == 4:
            if sys.argv[2] == "tofile":
                xmlfile = sys.argv[3]
                tofile = True
            elif sys.argv[3] == "tofile":
                xmlfile = sys.argv[2]
                tofile = True
            else:
                _die("Error, bad arguments", 1)
        elif len(sys.argv) > 4:
            _die("Error, you gave too much arguments", 1)

        plot_proj_dos(xmlfile, tofile)

    else:
        _die("This option is still not implemented")

    if opt in ["sp", "spb", "restart"]:
        print("\nCAREFULLY look at the input files before running the calculation")

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
# Manage calculations
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

def makeRestart(dirname):
    """ copy necessary files for restarting a vasp calculation """

    print("# copying input files")
    wd = os.getcwd()
    ndir = os.path.join(wd, dirname)

    # create directory
    if os.path.exists(ndir):
        if not question(dirname + " directory exists, continue ?"):
            _die()
    else:
        os.mkdir(ndir)
        
    # copy input files
    for f in ["INCAR", "POTCAR", "KPOINTS"]:
        if os.path.exists(os.path.join(wd, f)):
            print("cp " + f + " -> " + ndir)
            shutil.copy(os.path.join(wd, f), ndir)
        else:
            _die("File {0} does not exist".format(f), 1)

    # CONTCAR -> POSCAR
    if os.path.exists(os.path.join(wd, "CONTCAR")):
        print("cp CONTCAR -> " + os.path.join(ndir, "POSCAR"))
        shutil.copy(os.path.join(wd, "CONTCAR"), os.path.join(ndir, "POSCAR"))
    else:
        _die("CONTCAR file not found", 1)

    # WAVECAR, CHGCAR
    for f in ["WAVECAR", "CHGCAR"]:
        if os.path.exists(f) and os.path.getsize(f) != 0:
            print("cp " + f + " -> " + ndir)
            shutil.copy(os.path.join(wd, f), ndir)

    # job file
    jobs  = fnmatch.filter(os.listdir(wd), "j*")
    jobs += fnmatch.filter(os.listdir(wd), "*.job")
    jobs = [job for job in jobs if not fnmatch.fnmatchcase(job, "*.o*")]
    if len(jobs) == 1:
        print("cp " + jobs[0] + " -> " + ndir)
        shutil.copy(os.path.join(wd, jobs[0]), ndir)
    elif len(jobs) > 1:
        if question("Do you want to select a job file ?"):
            print("\nSelect a job file among:")
            for i, job in enumerate(jobs):
                print("     %d : %s" % (i, job))
            job = jobs[int(raw_input("job file number = "))]
            print("cp " + job + " -> " + ndir)
            shutil.copy(os.path.join(wd, job), ndir)
    else:
        print("I did not find a job file, copy it by yourself")

def makeSP():
    """ copy necessary files for a single point energy calculation into a
    directory called SinglePoint. The new INCAR file is modified in the
    following way:
        * NSW    -> NSW = 0
        * ISMEAR -> ISMEAR = -5
        * EDIFFG -> deleted
        * IBRION -> deleted
        * ISIF   -> deleted
        * LREAL  -> deleted
        * SIGMA  -> deleted
    """

    wd = os.getcwd()
    dirname = "SinglePoint"
    spdir = os.path.join(wd, dirname)

    # copy files
    makeRestart(dirname)

    # read INCAR and delete or change lines
    print("\n# Changing INCAR file")
    incar = open(os.path.join(wd, "INCAR"), "r").readlines()

    lorbit = False
    dline = list()
    for i, line in enumerate(incar):
        for tag in ["EDIFFG", "IBRION", "ISIF", "LREAL", "SIGMA"]:
            if tag in line:
                dline.append(line)

        if "NSW" in line:
            incar[i] = "  NSW = 0\n"

        elif "ISMEAR" in line:
            incar[i] = "  ISMEAR = -5\n"

        elif "LORBIT" in line:
            lorbit = True

    # remove selected line
    for line in dline:
        incar.remove(line)

    # add some keywords
    if not lorbit:
        incar.append("\nAdded tags\n")
        incar.append("  LORBIT = 11\n")

    # write new INCAR
    open(os.path.join(spdir, "INCAR"), "w").writelines(incar)

def makeSPBader():
    """ copy necessary files for a single point energy calculation into a
    directory called SinglePoint and add specific key words necessary for a
    bader charges calculation. The new INCAR file is modified in the
    following way:
        * NSW    -> NSW = 0
        * ISMEAR -> ISMEAR = -5
        * EDIFFG -> deleted
        * IBRION -> deleted
        * ISIF   -> deleted
        * LREAL  -> deleted
        * SIGMA  -> deleted
        * LAECHG -> added LAECHG = True
    """

    wd = os.getcwd()
    dirname = "SinglePoint"
    spdir = os.path.join(wd, dirname)

    # set up singlePoint calculation
    makeSP()

    # read INCAR and delete or change lines
    print("\n# Adding bader keywords")
    incar = open(os.path.join(spdir, "INCAR"), "r").readlines()

    dline = list()
    present = False
    for i, line in enumerate(incar):
        for tag in ["LAECHG", "NGXF", "NGYF", "NGZF"]:
            if tag in line:
                present = True
                dline.append(line)

    # remove selected line
    if present:
        print("Some bader related keywords are presents and might be modified.")
        for line in dline:
            print(line[:-1])
        if question("\nThese lines will be deleted. Continu ?"):
            for line in dline:
                incar.remove(line)
        else:
            _die()

    # read CONTCAR file
    poscar = open(os.path.join(spdir, "POSCAR"), "r").readlines()
    scale = float(poscar[1])
    veca  = [scale * float(x) for x in poscar[2].split()[0:3]]
    vecb  = [scale * float(x) for x in poscar[3].split()[0:3]]
    vecc  = [scale * float(x) for x in poscar[4].split()[0:3]]
    a = sqrt(veca[0]**2 + veca[1]**2 + veca[2]**2)
    b = sqrt(vecb[0]**2 + vecb[1]**2 + vecb[2]**2)
    c = sqrt(vecc[0]**2 + vecc[1]**2 + vecc[2]**2)

    # bader grid
    dx = 0.03
    if not question("dx = %f \t accept ?" % dx):
        print("Enter a new dx value")
        dx = float(raw_input("dx = "))
        print("dx = %f" % dx)
    ngxf = int(ceil(a / dx / 10.) * 10)
    ngyf = int(ceil(b / dx / 10.) * 10)
    ngzf = int(ceil(c / dx / 10.) * 10)

    print("Bader grid :")
    print("dx = {0} ".format(dx))
    print("a = %8.3f      NGXF = %d" % (a, ngxf))
    print("b = %8.3f      NGYF = %d" % (b, ngyf))
    print("c = %8.3f      NGZF = %d" % (c, ngzf))

    # add bader keywords
    incar.append("\nBader\n")
    incar.append("  LAECHG = True\n")
    incar.append("  NGXF = %d\n" % ngxf)
    incar.append("  NGYF = %d\n" % ngyf)
    incar.append("  NGZF = %d\n" % ngzf)

    # write new INCAR
    open(os.path.join(spdir, "INCAR"), "w").writelines(incar)

def cleanVasp():
    """ delete vasp output files """
    wd = os.getcwd()
    files = ["IBZKPT", "OSZICAR", "XDATCAR", "PCDAT", "DOSCAR", "CONTCAR",
             "CHG", "CHGCAR", "WAVECAR", "PROCAR", "EIGENVAL", "vasprun.xml",
             "OUTCAR", "DYNMAT"]
    for f in files:
        if os.path.exists(os.path.join(wd, f)):
            print("rm " + os.path.join(wd, f))
            os.remove(os.path.join(wd, f))

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
# extract data
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

def cell(poscar="CONTCAR"):
    """ 
    Compute and print lattice parameters 
    
    Args:
        poscar(string): file name
    """

    # check data
    if not os.path.exists(poscar):
        _die("Error : file {0} does not exist".format(poscar), 1)

    # read poscar file
    lines = open(poscar, "r").readlines()
    title = lines[0][0:-1]
    scale = float(lines[1])
    veca  = [scale * float(v) for v in lines[2].split()[0:3]]
    vecb  = [scale * float(v) for v in lines[3].split()[0:3]]
    vecc  = [scale * float(v) for v in lines[4].split()[0:3]]

    # lattice parameters
    a = sqrt(veca[0]**2 + veca[1]**2 + veca[2]**2)
    b = sqrt(vecb[0]**2 + vecb[1]**2 + vecb[2]**2)
    c = sqrt(vecc[0]**2 + vecc[1]**2 + vecc[2]**2)

    # angles
    scalab = veca[0] * vecb[0] + veca[1] * vecb[1] + veca[2] * vecb[2]
    scalac = veca[0] * vecc[0] + veca[1] * vecc[1] + veca[2] * vecc[2]
    scalbc = vecb[0] * vecc[0] + vecb[1] * vecc[1] + vecb[2] * vecc[2]

    scalab /= a * b
    scalac /= a * c
    scalbc /= b * c

    # alpha
    if fabs(scalbc) < 1.:
        alpha = acos(scalbc) * 180. / pi
    else:
        _die("Error, angle alpha")

    if fabs(scalac) < 1.:
        beta = acos(scalac) * 180. / pi
    else:
        _die("Error, angle beta")

    if fabs(scalab) < 1.:
        gamma = acos(scalab) * 180. / pi
    else:
        _die("Error, angle gamma")

    print(dashedLine)
    print(poscar + " : " + title)
    print(dashedLine)
    print("a     = %10.5f" % a)
    print("b     = %10.5f" % b)
    print("c     = %10.5f" % c)
    print("alpha = %10.3f" % alpha)
    print("beta  = %10.3f" % beta)
    print("gamma = %10.3f" % gamma)
    print(dashedLine)

def coreLevel():
    """ extract core level """

    AOname = ["s", "p", "d", "f"]

    try:
        from pymatgen.io.vaspio.vasp_output import Outcar
        from pymatgen.io.vaspio.vasp_input import Incar
        import pymatgen as mg

        cl = Outcar("OUTCAR").read_core_state_eigen()
        symbol = [specie.symbol for specie in mg.read_structure("POSCAR").species]

        if len(sys.argv) == 2:
            # try to read from INCAR
            incar = Incar.from_file("INCAR")
            iat = incar["CLNT"]

            n = incar["CLN"]
            l = incar["CLL"]

            ao = "%d%s" % (n, AOname[l])

        elif sys.argv[2] == "select":
            # ask for atom number and orbital
            print("    atom    Atomic orbital")
            for iat, cl_at in enumerate(cl):
                line = "%4s %4d    " % (symbol[iat], iat + 1)
                line += "   ".join(cl_at.keys())
                print(line)

            iat = int(raw_input("Atom number : "))
            ao = raw_input("atomic orbital : ")

        else:
            # atom and AO selected from command line
            try:
                iat = int(sys.argv[2])
            except ValueError:
                _die("Error atom number must be an integer", 1)

            ao = sys.argv[3]

        # print core state energy
        if cl[iat-1].has_key(ao):
            print("atom %d -> %2s_%2s = %f eV" % (iat, symbol[iat-1], ao, \
                cl[iat-1][ao][-1]))
        else:
            _die("Atom index and AO unconsistent.\
                \n    atom: %s %d\n    AO  : %s" % (symbol[iat-1], iat, ao), 1)

    except ImportError:
        _die("\n ## Pymatgen may be not available ##", 1)

def plot_total_dos(xmlfile="vasprun.xml", tofile=False):
    """ Plot total DOS using matplotlib """

    # check xml file
    if not os.path.exists(xmlfile):
        _die("File %s does not exist" % xmlfile, 1)

    # import pymatgen and matplotlib
    try:
        from pymatgen.io.vaspio.vasp_output import Vasprun
        from pymatgen.electronic_structure.core import Spin
    except ImportError:
        _die("\n ## Pymatgen may be not available ##", 1)

    if not tofile:
        try:
            import matplotlib.pyplot as plt
        except ImportError:
            _die("\n ## Matplotlib may be not available ##", 1)

    # read
    run = Vasprun(xmlfile, parse_eigen=False)

    if tofile:
        if not run.is_spin:
            lines = "#  E - Ef       total\n"
            for e, tdos in zip(run.tdos.energies, run.tdos.densities[Spin.up]):
                lines += "%12.7f %12.7f\n" % (e - run.efermi, tdos)
        else:
            lines = "#  E - Ef        Spin up      Spin down\n"
            for e, up, down in zip(run.tdos.energies, \
                    run.tdos.densities[Spin.up], \
                    run.tdos.densities[Spin.down]):
                lines += "%12.7f %12.7f %12.7f\n" % (e - run.efermi, up, -down)
        open("total_DOS.dat", "w").write(lines)

    else:
        # plot
        font = {'family': 'serif', 'size': 20}
        plt.rc('font', **font)
        plt.figure(figsize=(11.69, 8.27)) # A4

        plt.plot(run.tdos.energies - run.efermi, run.tdos.densities[Spin.up],
            "r-", label="Spin up")
        if run.is_spin:
            plt.plot(run.tdos.energies - run.efermi, -run.tdos.densities[Spin.down], 
                "b-", label="Spin down")

        # set up figure
        plt.title("Density of states of " + \
            run.initial_structure.composition.reduced_formula)
        plt.xlabel(r"$E - E_{f}$   /   eV")
        plt.ylabel("Density of states")
        plt.grid()
        ymin, ymax = plt.ylim()
        plt.vlines(0, ymin, ymax, color="k", lw=1, linestyle="--")
        if run.is_spin:
            xmin, xmax = plt.xlim()
            plt.hlines(0, xmin, xmax, color="k", lw=1)
            plt.legend(fancybox=True,shadow=True, prop={"size":18})
        else:
            ymin, ymax = plt.ylim()
            plt.ylim(0, ymax)

        plt.show()

def plot_proj_dos(xmlfile="vasprun.xml", tofile=False):
    """ Plot projected DOS using matplotlib """

    # check xml file
    if not os.path.exists(xmlfile):
        _die("File %s does not exist" % xmlfile, 1)

    # import pymatgen and matplotlib
    try:
        from pymatgen.io.vaspio.vasp_output import Vasprun
        from pymatgen.electronic_structure.core import Spin
    except ImportError:
        _die("\n ## Pymatgen may be not available ##", 1)

    if not tofile:
        try:
            import matplotlib.pyplot as plt
        except ImportError:
            _die("\n ## Matplotlib may be not available ##", 1)

    # read
    run = Vasprun(xmlfile, parse_eigen=False)
    dos = run.complete_dos

    if tofile:
        el_tdos = dos.get_element_dos()
        for el, tdos in el_tdos.items():
            el_dos = dos.get_element_spd_dos(el)
            lines = "# Element: %s\n" % el.symbol
            lines += "# column 1: E - E_fermi\n"
            if not run.is_spin:
                lines += "# column 2: DOS projected on %s\n" % el.symbol
                lines += "# column 3: DOS projected on AO type s\n"
                lines += "# column 4: DOS projected on AO type p\n"
                lines += "# column 5: DOS projected on AO type d\n"
                for i in xrange(len(dos.energies)):
                    lines += "%12.7f" % (dos.energies[i] - dos.efermi)
                    lines += "%12.7f" %  tdos.densities[Spin.up][i]
                    lines += "%12.7f" %  el_dos["S"][Spin.up][i]
                    lines += "%12.7f" %  el_dos["P"][Spin.up][i]
                    lines += "%12.7f" %  el_dos["D"][Spin.up][i]
                    lines += "\n"

            else:
                lines += "# column 2: DOS up projected on %s\n" % el.symbol
                lines += "# column 3: DOS down projected on %s\n" % el.symbol
                lines += "# column 4: DOS up projected on AO type s\n"
                lines += "# column 5: DOS down projected on AO type s\n"
                lines += "# column 6: DOS up projected on AO type p\n"
                lines += "# column 7: DOS down projected on AO type p\n"
                lines += "# column 8: DOS up projected on AO type d\n"
                lines += "# column 9: DOS down projected on AO type d\n"
                for i in xrange(len(dos.energies)):
                    lines += "%12.7f" % (dos.energies[i] - dos.efermi)
                    lines += "%12.7f" %  tdos.densities[Spin.up][i]
                    lines += "%12.7f" % -tdos.densities[Spin.down][i]
                    lines += "%12.7f" %  el_dos["S"][Spin.up][i]
                    lines += "%12.7f" % -el_dos["S"][Spin.down][i]
                    lines += "%12.7f" %  el_dos["P"][Spin.up][i]
                    lines += "%12.7f" % -el_dos["P"][Spin.down][i]
                    lines += "%12.7f" %  el_dos["D"][Spin.up][i]
                    lines += "%12.7f" % -el_dos["D"][Spin.down][i]
                    lines += "\n"

            open("DOS_%s.dat" % el.symbol, "w").write(lines)

    else:
        # plot
        font = {'family': 'serif', 'size': 20}
        plt.rc('font', **font)
        plt.figure(figsize=(11.69, 8.27)) # A4

        colors = {"S": "r-", "P": "g-", "D": "b-"}
        nplots = len(dos.structure.composition.elements)
        for i, el in enumerate(dos.structure.composition.elements):
            el_dos = dos.get_element_spd_dos(el)
            plt.subplot(nplots,1,i+1)
            plt.plot(dos.energies - dos.efermi, dos.densities[Spin.up], "k-", 
                label="total")
            for orb, pdos in el_dos.items():
                plt.plot(dos.energies - dos.efermi, pdos[Spin.up], colors[orb],
                    label=orb.lower())

            if run.is_spin:
                plt.plot(dos.energies - dos.efermi, -dos.densities[Spin.down],
                    "k-")
                for orb, pdos in el_dos.items():
                    plt.plot(dos.energies - dos.efermi, -pdos[Spin.down],
                        colors[orb])
                xmin, xmax = plt.xlim()
                plt.hlines(0, xmin, xmax, color="k")

            ymin, ymax = plt.ylim()
            plt.vlines(0, ymin, ymax, color="k", linestyle="-")
            plt.ylim(ymin, ymax)
            plt.ylabel("Element : " + el.symbol)
            plt.grid()
            plt.legend(prop={"size": "18"})
        
        #plt.subplots_adjust(hspace=0.)
        plt.suptitle("Projected DOS of elements of " + \
            run.initial_structure.composition.reduced_formula)
        plt.xlabel(r"$E - E_{f}$   /   eV")

        plt.show()

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
# compute things
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

def chgsum():
    """ linear add of CHGCAR files """

    try:
        from pymatgen.io.vaspio.vasp_output import Chgcar

        scale_factor = 1.

        # command line options
        if len(sys.argv) == 4:
            chgcar1 = sys.argv[2]
            chgcar2 = sys.argv[3]

        elif len(sys.argv) == 5:
            chgcar1 = sys.argv[2]
            chgcar2 = sys.argv[3]
            try:
                scale_factor = float(sys.argv[4])
            except ValueError:
                _die("Error, scale_factor must be a number", 1)
        else:
            _die("Error in arguemnts list. try {0} -h to get some \
                help".format(sys.argv[0]), 1)
            
        # ask if you agree the computation
        print("I will compute : {0} + {1}*{2}".format(chgcar1, scale_factor,\
            chgcar2))

        if not question("Do you agree ?"):
            _die()

        # files exist ?
        if not os.path.exists(chgcar1):
            _die("Error : File '{0}' does not exist !\n".format(chgcar1))

        if not os.path.exists(chgcar2):
            _die("Error : File '{0}' does not exist !\n".format(chgcar2))

        # sum densities
        print("Reading {0}".format(chgcar1))
        rho1 = Chgcar.from_file(chgcar1)
        print("Reading {0}".format(chgcar2))
        rho2 = Chgcar.from_file(chgcar2)
        rho_sum = rho1.linear_add(rho2, scale_factor)

        # name of output file
        print(dashedLine)
        if os.path.exists("CHGCAR_sum"):
            if not question("file CHGCAR_sum exists, overwrite it ?"):
                _die()
        print(" write sum density in : CHGCAR_sum\n" + dashedLine)
        rho_sum.write_file("CHGCAR_sum")

    except ImportError:
        _die("\n ## Pymatgen may be not available ##", 1)

if __name__ == "__main__":
    check()
    select()

