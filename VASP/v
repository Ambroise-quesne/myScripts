#!/usr/bin/env python
# -*- coding=utf-8 -*-

"""
Manage VASP job operation and extract interesting data.

This script does not run the calculation. You have to check the input files
before !!

SYNTAX 
        v <sub-command> [OPTIONS]

SUB-COMMANDS

    get help
    --------
 
        -h, --hep, h, help
            print this help and exit.

    Manage calculations
    -------------------

        clean
            delete vasp output files

        restart
            copy necessary files for a restart calculation into a restart
            directory. None of the copied files are modified.

        sp
            copy the necessary files for an energy calculation into a 
            SinglePoint directory. In the new INCAR file, the following 
            keywords are changed:
                * NSW    -> NSW = 0
                * ISMEAR -> ISMEAR = -5
                * EDIFFG -> deleted
                * IBRION -> deleted
                * ISIF   -> deleted
                * LREAL  -> deleted
                * SIGMA  -> deleted

        spb
            Do the same things as sp but add keywords for a Bader calculation:
                * LAECHG = True
                * NGXF   = XXX
                * NGYF   = YYY
                * NGZF   = ZZZ

            The values of XXX, YYY and ZZZ are computed from lattice parameters
            assuming a distance between grid points of 0.03A.

    Extract data
    ------------

        cell [FILENAME]
            print lattice parameters calculated from [FILENAME]. [FILENAME]
            must be a POSCAR/CONTCAR file. If [FILENAME] is absent, a list of
            available POSCAR/CONTCAR files in the working directory is printed.

        cl [OPTIONS]
            Read core state eigenenergies from OUTCAR file (need pymatgen).

            v cl
                Read the INCAR file and output core state eigenergy of the AO
                of the atom define by CLNT, CLN and CLL keywords.

            v cl select
                Output all available core state eigenergies and ask for the
                atom index and the AO name of the core state.

            c cl [atom index] [atomic orbital]
                Output the core state eigenergies of the atom and the atomic
                orbital defined in the options. The first atom index is 1.
                [atomic orbital] is something like 1s, 2p, 3s ...

        tdos ['FILENAME', tofile]
            read DOS from 'vasprun.xml' or from 'FILENAME' and plot it using
            matplotlib (need pymatgen). 'FILENAME' must be a valid vasprun.xml
            file. 
            If tofile is present, the total DOS is printed into a file named
            'total_DOS.dat'.

        pdos ['FILENAME', tofile]
            read projected DOS from 'vasprun.xml' or from 'FILENAME' and plot
            it using matplotlib (need pymatgen). 'FILENAME' must be a valid 
            vasprun.xml file.
            If tofile is present, for each element, projected DOS are printed
            into a file named 'DOS_X.dat' where X is the symbol of the
            element.

        mag
            read OUTCAR and POSCAR file and print magnetization of each atom at
            the last ionic step.

        charges
            After a bader calculation
            `http://http://theory.cm.utexas.edu/henkelman/code/bader/`_
            Read atomic populations into ACF.dat file and compute atomic
            charges using data in POTCAR file and atom names in POSCAR file.

    Compute data
    ------------

        chgsum [CHGCAR1] [CHGCAR2] [factor]
            Compute CHGCAR1 + factor * CHGCAR2 where CHGCAR are denisty file.
            This command needs pymatgen.

        dep [FILE1, FILE2]
            Compute displacements of all atoms in two structures. By default,
            the vasprun.xml file is read and initial and final structures are
            compared. Two POSCAR/CONTCAR file can be also given in arguements.

REMARK
        Job files are supposed to begin by 'j' or to have  a '.job' extension.

        Some functions may need pymatgen module (see http://www.pymatgen.org).
        
"""

from __future__ import division, print_function

import sys
import os
import shutil
import fnmatch

from math import sqrt, acos, pi, fabs, ceil

__author__ = "Germain Salvato-Vallverdu"
__email__ = "germain.vallverdu@univ-pau.fr"
__licence__ = "GPL"
__date__ = "June 2014"

dashedLine = "".join(50 * ["-"])

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
# General functions
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

def _die(m="", code=0):
    """ print error and exit """
    print(m)
    exit(code)

def question(message):
    """ ask a question and read answer """
    answer = None
    while answer is None:
        a = raw_input(message + " (y/n) : ")
        if a.lower()[0] == "n":
            answer = False
        elif a.lower()[0] == "y" or a.lower()[0] == "o":
            answer = True
        else:
            print("hit 'y' for yes or 'n' for no")
    return answer

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
# Check and select functions
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

def check():
    """ check options """

    if len(sys.argv) < 2:
        _die("\nERROR, you must give a sub-command", 1)

    options = ["h", "help", "-h", "--help",
               "clean", "sp", "spb", "restart",
               "cell", "cl", "chgsum", "charges",
               "tdos", "pdos", "mag", "dep"]

    opt = sys.argv[1]
    if opt not in options:
        _die("\nERROR, option '%s' unknown" % opt, 1)

def select():
    """ select the operation to do """

    wd = os.getcwd()

    # help
    for opt in sys.argv:
        if opt in ["h", "help", "-h", "--help"]:
            _die(__doc__)

    # command name 
    opt = sys.argv[1].lower()

    if opt == "clean":
        cleanVasp()
    elif opt == "sp":
        makeSP()
    elif opt == "spb":
        makeSPBader()
    elif opt == "restart":
        makeRestart("restart")

    elif opt == "cell":
        # POSCAR file
        narg = len(sys.argv)
        if narg == 2:
            print(wd + ":")
            posfile  = fnmatch.filter(os.listdir(wd), "POSCAR*")
            posfile += fnmatch.filter(os.listdir(wd), "CONTCAR*")
            posfile += fnmatch.filter(os.listdir(wd), "*.vasp")
            for i, f in enumerate(posfile):
                print("    %3d -> %s" % (i, f))
            poscar = posfile[int(raw_input("\nfile number = "))]

        elif narg == 3:
            poscar = sys.argv[2]

        else:
            _die("Error, bad arguments.", 1)

        cell(poscar) 

    elif opt == "cl":
        coreLevel()

    elif opt == "tdos":
        tofile = False
        xmlfile = "vasprun.xml"

        if len(sys.argv) == 3:
            if sys.argv[2] == "tofile":
                tofile = True
            else:
                xmlfile = sys.argv[2]
        elif len(sys.argv) == 4:
            if sys.argv[2] == "tofile":
                xmlfile = sys.argv[3]
                tofile = True
            elif sys.argv[3] == "tofile":
                xmlfile = sys.argv[2]
                tofile = True
            else:
                _die("Error, bad arguments", 1)
        elif len(sys.argv) > 4:
            _die("Error, you gave too much arguments", 1)

        plot_total_dos(xmlfile, tofile)

    elif opt == "pdos":
        tofile = False
        xmlfile = "vasprun.xml"

        if len(sys.argv) == 3:
            if sys.argv[2] == "tofile":
                tofile = True
            else:
                xmlfile = sys.argv[2]
        elif len(sys.argv) == 4:
            if sys.argv[2] == "tofile":
                xmlfile = sys.argv[3]
                tofile = True
            elif sys.argv[3] == "tofile":
                xmlfile = sys.argv[2]
                tofile = True
            else:
                _die("Error, bad arguments", 1)
        elif len(sys.argv) > 4:
            _die("Error, you gave too much arguments", 1)

        plot_proj_dos(xmlfile, tofile)

    elif opt == "mag":
        get_mag()

    elif opt == "charges":
        if len(sys.argv) == 3:
            filename = sys.argv[2]
        else:
            filename = None
        charges(filename)

    elif opt == "chgsum":
        chgsum()

    elif opt == "dep":
        xmlfile = "vasprun.xml"
        fs1 = fs2 = None
        if len(sys.argv) == 3:
            xmlfile = sys.argv[2]
        elif len(sys.argv) == 4:
            xmlfile = None
            fs1 = sys.argv[2]
            fs2 = sys.argv[3]

        get_deplacement(xmlfile, fs1, fs2)

    else:
        _die("This option is still not implemented")

    if opt in ["sp", "spb", "restart"]:
        print("\nCAREFULLY look at the input files before running the calculation")

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
# Manage calculations
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

def makeRestart(dirname):
    """ copy necessary files for restarting a vasp calculation """

    print("# copying input files")
    wd = os.getcwd()
    ndir = os.path.join(wd, dirname)

    # create directory
    if os.path.exists(ndir):
        if not question(dirname + " directory exists, continue ?"):
            _die()
    else:
        os.mkdir(ndir)
        
    # copy input files
    for f in ["INCAR", "POTCAR", "KPOINTS"]:
        if os.path.exists(os.path.join(wd, f)):
            print("cp " + f + " -> " + ndir)
            shutil.copy(os.path.join(wd, f), ndir)
        else:
            _die("File {0} does not exist".format(f), 1)

    # CONTCAR -> POSCAR
    if os.path.exists(os.path.join(wd, "CONTCAR")):
        print("cp CONTCAR -> " + os.path.join(ndir, "POSCAR"))
        shutil.copy(os.path.join(wd, "CONTCAR"), os.path.join(ndir, "POSCAR"))
    else:
        _die("CONTCAR file not found", 1)

    # WAVECAR, CHGCAR
    for f in ["WAVECAR", "CHGCAR"]:
        if os.path.exists(f) and os.path.getsize(f) != 0:
            print("cp " + f + " -> " + ndir)
            shutil.copy(os.path.join(wd, f), ndir)

    # job file
    jobs  = fnmatch.filter(os.listdir(wd), "j*")
    jobs += fnmatch.filter(os.listdir(wd), "*.job")
    jobs = [job for job in jobs if not fnmatch.fnmatchcase(job, "*.o*")]
    if len(jobs) == 1:
        print("cp " + jobs[0] + " -> " + ndir)
        shutil.copy(os.path.join(wd, jobs[0]), ndir)
    elif len(jobs) > 1:
        if question("Do you want to select a job file ?"):
            print("\nSelect a job file among:")
            for i, job in enumerate(jobs):
                print("     %d : %s" % (i, job))
            job = jobs[int(raw_input("job file number = "))]
            print("cp " + job + " -> " + ndir)
            shutil.copy(os.path.join(wd, job), ndir)
    else:
        print("I did not find a job file, copy it by yourself")

def makeSP():
    """ copy necessary files for a single point energy calculation into a
    directory called SinglePoint. The new INCAR file is modified in the
    following way:
        * NSW    -> NSW = 0
        * ISMEAR -> ISMEAR = -5
        * EDIFFG -> deleted
        * IBRION -> deleted
        * ISIF   -> deleted
        * LREAL  -> deleted
        * SIGMA  -> deleted
    """

    wd = os.getcwd()
    dirname = "SinglePoint"
    spdir = os.path.join(wd, dirname)

    # copy files
    makeRestart(dirname)

    # read INCAR and delete or change lines
    print("\n# Changing INCAR file")
    incar = open(os.path.join(wd, "INCAR"), "r").readlines()

    lorbit = False
    dline = list()
    for i, line in enumerate(incar):
        for tag in ["EDIFFG", "IBRION", "ISIF", "LREAL", "SIGMA"]:
            if tag in line:
                dline.append(line)

        if "NSW" in line:
            incar[i] = "  NSW = 0\n"

        elif "ISMEAR" in line:
            incar[i] = "  ISMEAR = -5\n"

        elif "LORBIT" in line:
            lorbit = True

    # remove selected line
    for line in dline:
        incar.remove(line)

    # add some keywords
    if not lorbit:
        incar.append("\nAdded tags\n")
        incar.append("  LORBIT = 11\n")

    # write new INCAR
    open(os.path.join(spdir, "INCAR"), "w").writelines(incar)

def makeSPBader():
    """ copy necessary files for a single point energy calculation into a
    directory called SinglePoint and add specific key words necessary for a
    bader charges calculation. The new INCAR file is modified in the
    following way:
        * NSW    -> NSW = 0
        * ISMEAR -> ISMEAR = -5
        * EDIFFG -> deleted
        * IBRION -> deleted
        * ISIF   -> deleted
        * LREAL  -> deleted
        * SIGMA  -> deleted
        * LAECHG -> added LAECHG = True
    """

    wd = os.getcwd()
    dirname = "SinglePoint"
    spdir = os.path.join(wd, dirname)

    # set up singlePoint calculation
    makeSP()

    # read INCAR and delete or change lines
    print("\n# Adding bader keywords")
    incar = open(os.path.join(spdir, "INCAR"), "r").readlines()

    dline = list()
    present = False
    for i, line in enumerate(incar):
        for tag in ["LAECHG", "NGXF", "NGYF", "NGZF"]:
            if tag in line:
                present = True
                dline.append(line)

    # remove selected line
    if present:
        print("Some bader related keywords are presents and might be modified.")
        for line in dline:
            print(line[:-1])
        if question("\nThese lines will be deleted. Continu ?"):
            for line in dline:
                incar.remove(line)
        else:
            _die()

    # read CONTCAR file
    poscar = open(os.path.join(spdir, "POSCAR"), "r").readlines()
    scale = float(poscar[1])
    veca  = [scale * float(x) for x in poscar[2].split()[0:3]]
    vecb  = [scale * float(x) for x in poscar[3].split()[0:3]]
    vecc  = [scale * float(x) for x in poscar[4].split()[0:3]]
    a = sqrt(veca[0]**2 + veca[1]**2 + veca[2]**2)
    b = sqrt(vecb[0]**2 + vecb[1]**2 + vecb[2]**2)
    c = sqrt(vecc[0]**2 + vecc[1]**2 + vecc[2]**2)

    # bader grid
    dx = 0.03
    if not question("dx = %f \t accept ?" % dx):
        print("Enter a new dx value")
        dx = float(raw_input("dx = "))
        print("dx = %f" % dx)
    ngxf = int(ceil(a / dx / 10.) * 10)
    ngyf = int(ceil(b / dx / 10.) * 10)
    ngzf = int(ceil(c / dx / 10.) * 10)

    print("Bader grid :")
    print("dx = {0} ".format(dx))
    print("a = %8.3f      NGXF = %d" % (a, ngxf))
    print("b = %8.3f      NGYF = %d" % (b, ngyf))
    print("c = %8.3f      NGZF = %d" % (c, ngzf))

    # add bader keywords
    incar.append("\nBader\n")
    incar.append("  LAECHG = True\n")
    incar.append("  NGXF = %d\n" % ngxf)
    incar.append("  NGYF = %d\n" % ngyf)
    incar.append("  NGZF = %d\n" % ngzf)

    # write new INCAR
    open(os.path.join(spdir, "INCAR"), "w").writelines(incar)

def cleanVasp():
    """ delete vasp output files """
    wd = os.getcwd()
    files = ["IBZKPT", "OSZICAR", "XDATCAR", "PCDAT", "DOSCAR", "CONTCAR",
             "CHG", "CHGCAR", "WAVECAR", "PROCAR", "EIGENVAL", "vasprun.xml",
             "OUTCAR", "DYNMAT"]
    for f in files:
        if os.path.exists(os.path.join(wd, f)):
            print("rm " + os.path.join(wd, f))
            os.remove(os.path.join(wd, f))

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
# extract data
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

def cell(poscar="CONTCAR"):
    """ 
    Compute and print lattice parameters 
    
    Args:
        poscar(string): file name
    """

    # check data
    if not os.path.exists(poscar):
        _die("Error : file {0} does not exist".format(poscar), 1)

    # read poscar file
    lines = open(poscar, "r").readlines()
    title = lines[0][0:-1]
    scale = float(lines[1])
    veca  = [scale * float(v) for v in lines[2].split()[0:3]]
    vecb  = [scale * float(v) for v in lines[3].split()[0:3]]
    vecc  = [scale * float(v) for v in lines[4].split()[0:3]]

    # lattice parameters
    a = sqrt(veca[0]**2 + veca[1]**2 + veca[2]**2)
    b = sqrt(vecb[0]**2 + vecb[1]**2 + vecb[2]**2)
    c = sqrt(vecc[0]**2 + vecc[1]**2 + vecc[2]**2)

    # angles
    scalab = veca[0] * vecb[0] + veca[1] * vecb[1] + veca[2] * vecb[2]
    scalac = veca[0] * vecc[0] + veca[1] * vecc[1] + veca[2] * vecc[2]
    scalbc = vecb[0] * vecc[0] + vecb[1] * vecc[1] + vecb[2] * vecc[2]

    scalab /= a * b
    scalac /= a * c
    scalbc /= b * c

    # alpha
    if fabs(scalbc) < 1.:
        alpha = acos(scalbc) * 180. / pi
    else:
        _die("Error, angle alpha")

    if fabs(scalac) < 1.:
        beta = acos(scalac) * 180. / pi
    else:
        _die("Error, angle beta")

    if fabs(scalab) < 1.:
        gamma = acos(scalab) * 180. / pi
    else:
        _die("Error, angle gamma")

    print(dashedLine)
    print(poscar + " : " + title)
    print(dashedLine)
    print("a     = %10.5f" % a)
    print("b     = %10.5f" % b)
    print("c     = %10.5f" % c)
    print("alpha = %10.3f" % alpha)
    print("beta  = %10.3f" % beta)
    print("gamma = %10.3f" % gamma)
    print(dashedLine)

def coreLevel():
    """ extract core level """

    AOname = ["s", "p", "d", "f"]

    try:
        from pymatgen.io.vaspio.vasp_output import Outcar
        from pymatgen.io.vaspio.vasp_input import Incar
        import pymatgen as mg

        cl = Outcar("OUTCAR").read_core_state_eigen()
        symbol = [specie.symbol for specie in mg.read_structure("POSCAR").species]

        if len(sys.argv) == 2:
            # try to read from INCAR
            incar = Incar.from_file("INCAR")
            iat = incar["CLNT"]

            n = incar["CLN"]
            l = incar["CLL"]

            ao = "%d%s" % (n, AOname[l])

        elif sys.argv[2] == "select":
            # ask for atom number and orbital
            print("    atom    Atomic orbital")
            for iat, cl_at in enumerate(cl):
                line = "%4s %4d    " % (symbol[iat], iat + 1)
                line += "   ".join(cl_at.keys())
                print(line)

            iat = int(raw_input("Atom number : "))
            ao = raw_input("atomic orbital : ")

        else:
            # atom and AO selected from command line
            try:
                iat = int(sys.argv[2])
            except ValueError:
                _die("Error atom number must be an integer", 1)

            ao = sys.argv[3]

        # print core state energy
        if cl[iat-1].has_key(ao):
            print("atom %d -> %2s_%2s = %f eV" % (iat, symbol[iat-1], ao, \
                cl[iat-1][ao][-1]))
        else:
            _die("Atom index and AO unconsistent.\
                \n    atom: %s %d\n    AO  : %s" % (symbol[iat-1], iat, ao), 1)

    except ImportError:
        _die("\n ## Pymatgen may be not available ##", 1)

def plot_total_dos(xmlfile="vasprun.xml", tofile=False):
    """ Plot total DOS using matplotlib """

    # check xml file
    if not os.path.exists(xmlfile):
        _die("File %s does not exist" % xmlfile, 1)

    # import pymatgen and matplotlib
    try:
        from pymatgen.io.vaspio.vasp_output import Vasprun
        from pymatgen.electronic_structure.core import Spin
    except ImportError:
        _die("\n ## Pymatgen may be not available ##", 1)

    if not tofile:
        try:
            import matplotlib.pyplot as plt
        except ImportError:
            _die("\n ## Matplotlib may be not available ##", 1)

    # read
    run = Vasprun(xmlfile, parse_eigen=False)

    if tofile:
        if not run.is_spin:
            lines = "#  E - Ef       total\n"
            for e, tdos in zip(run.tdos.energies, run.tdos.densities[Spin.up]):
                lines += "%12.7f %12.7f\n" % (e - run.efermi, tdos)
        else:
            lines = "#  E - Ef        Spin up      Spin down\n"
            for e, up, down in zip(run.tdos.energies, \
                    run.tdos.densities[Spin.up], \
                    run.tdos.densities[Spin.down]):
                lines += "%12.7f %12.7f %12.7f\n" % (e - run.efermi, up, -down)
        open("total_DOS.dat", "w").write(lines)

    else:
        # plot
        font = {'family': 'serif', 'size': 20}
        plt.rc('font', **font)
        plt.figure(figsize=(11.69, 8.27)) # A4

        plt.plot(run.tdos.energies - run.efermi, run.tdos.densities[Spin.up],
            "r-", label="Spin up")
        if run.is_spin:
            plt.plot(run.tdos.energies - run.efermi, -run.tdos.densities[Spin.down], 
                "b-", label="Spin down")

        # set up figure
        plt.title("Density of states of " + \
            run.initial_structure.composition.reduced_formula)
        plt.xlabel(r"$E - E_{f}$   /   eV")
        plt.ylabel("Density of states")
        plt.grid()
        ymin, ymax = plt.ylim()
        plt.vlines(0, ymin, ymax, color="k", lw=1, linestyle="--")
        if run.is_spin:
            xmin, xmax = plt.xlim()
            plt.hlines(0, xmin, xmax, color="k", lw=1)
            plt.legend(prop={"size":18})
        else:
            ymin, ymax = plt.ylim()
            plt.ylim(0, ymax)

        plt.show()

def plot_proj_dos(xmlfile="vasprun.xml", tofile=False):
    """ Plot projected DOS using matplotlib """

    # check xml file
    if not os.path.exists(xmlfile):
        _die("File %s does not exist" % xmlfile, 1)

    # import pymatgen and matplotlib
    try:
        from pymatgen.io.vaspio.vasp_output import Vasprun
        from pymatgen.electronic_structure.core import Spin
    except ImportError:
        _die("\n ## Pymatgen may be not available ##", 1)

    if not tofile:
        try:
            import matplotlib.pyplot as plt
        except ImportError:
            _die("\n ## Matplotlib may be not available ##", 1)

    # read
    run = Vasprun(xmlfile, parse_eigen=False)
    dos = run.complete_dos

    if tofile:
        el_tdos = dos.get_element_dos()
        for el, tdos in el_tdos.items():
            el_dos = dos.get_element_spd_dos(el)
            lines = "# Element: %s\n" % el.symbol
            lines += "# column 1: E - E_fermi (eV)\n"
            if not run.is_spin:
                lines += "# column 2: DOS projected on %s\n" % el.symbol
                lines += "# column 3: DOS projected on AO type s\n"
                lines += "# column 4: DOS projected on AO type p\n"
                lines += "# column 5: DOS projected on AO type d\n"
                for i in xrange(len(dos.energies)):
                    lines += "%12.7f " % (dos.energies[i] - dos.efermi)
                    lines += "%12.7f " %  tdos.densities[Spin.up][i]
                    lines += "%12.7f " %  el_dos["S"][Spin.up][i]
                    lines += "%12.7f " %  el_dos["P"][Spin.up][i]
                    lines += "%12.7f " %  el_dos["D"][Spin.up][i]
                    lines += "\n"

            else:
                lines += "# column 2: DOS up projected on %s\n" % el.symbol
                lines += "# column 3: DOS down projected on %s\n" % el.symbol
                lines += "# column 4: DOS up projected on AO type s\n"
                lines += "# column 5: DOS down projected on AO type s\n"
                lines += "# column 6: DOS up projected on AO type p\n"
                lines += "# column 7: DOS down projected on AO type p\n"
                lines += "# column 8: DOS up projected on AO type d\n"
                lines += "# column 9: DOS down projected on AO type d\n"
                for i in xrange(len(dos.energies)):
                    lines += "%12.7f " % (dos.energies[i] - dos.efermi)
                    lines += "%12.7f " %  tdos.densities[Spin.up][i]
                    lines += "%12.7f " % -tdos.densities[Spin.down][i]
                    lines += "%12.7f " %  el_dos["S"][Spin.up][i]
                    lines += "%12.7f " % -el_dos["S"][Spin.down][i]
                    lines += "%12.7f " %  el_dos["P"][Spin.up][i]
                    lines += "%12.7f " % -el_dos["P"][Spin.down][i]
                    lines += "%12.7f " %  el_dos["D"][Spin.up][i]
                    lines += "%12.7f " % -el_dos["D"][Spin.down][i]
                    lines += "\n"

            open("DOS_%s.dat" % el.symbol, "w").write(lines)

    else:
        # plot
        font = {'family': 'serif', 'size': 20}
        plt.rc('font', **font)
        plt.figure(figsize=(11.69, 8.27)) # A4

        colors = {"S": "r-", "P": "g-", "D": "b-"}
        nplots = len(dos.structure.composition.elements)
        for i, el in enumerate(dos.structure.composition.elements):
            el_dos = dos.get_element_spd_dos(el)
            plt.subplot(nplots,1,i+1)
            plt.plot(dos.energies - dos.efermi, dos.densities[Spin.up], "k-", 
                label="total")
            for orb, pdos in el_dos.items():
                plt.plot(dos.energies - dos.efermi, pdos[Spin.up], colors[orb],
                    label=orb.lower())

            if run.is_spin:
                plt.plot(dos.energies - dos.efermi, -dos.densities[Spin.down],
                    "k-")
                for orb, pdos in el_dos.items():
                    plt.plot(dos.energies - dos.efermi, -pdos[Spin.down],
                        colors[orb])
                xmin, xmax = plt.xlim()
                plt.hlines(0, xmin, xmax, color="k")

            ymin, ymax = plt.ylim()
            plt.vlines(0, ymin, ymax, color="k", linestyle="-")
            plt.ylim(ymin, ymax)
            plt.ylabel("Element : " + el.symbol)
            plt.grid()
            plt.legend(prop={"size": "18"})
        
        #plt.subplots_adjust(hspace=0.)
        plt.suptitle("Projected DOS of elements of " + \
            run.initial_structure.composition.reduced_formula)
        plt.xlabel(r"$E - E_{f}$   /   eV")

        plt.show()

def get_mag():
    """ Read OUTCAR and POSCAR file and print magnetization """

    # import pymatgen
    try:
        from pymatgen.io.vaspio.vasp_output import Outcar
        from pymatgen.io.vaspio.vasp_input import Poscar
    except ImportError:
        _die("\n ## Pymatgen may be not available ##", 1)

    # check files exist
    for f in ["POSCAR", "OUTCAR"]:
        if not os.path.exists(f):
            _die("File %s is needed and does not exist" % f, 1)

    # read
    outcar = Outcar("OUTCAR")
    if len(outcar.magnetization) == 0:
        _die("Magnetization not found in OUTCAR file. Check INCAR", 1)

    # print
    p = Poscar.from_file("POSCAR")
    print("# magnetization for each atom")
    print("# ---------------------------------------")
    print("# iat name   s       p       d       tot")
    print("# ---------------------------------------")
    iat = 0
    for site, mag in zip(p.structure.sites, outcar.magnetization):
        iat += 1
        line = "%4d %4s" % (iat, site.specie.symbol)
        for val in mag.values():
            line += "%8.3f" % val
        print(line)
    print("# ---------------------------------------")
    

def charges(filename=None):
    """
    Compute atomic charges from a Bader caclculations done with the bader
    program of the University of Texas at Austin :

    http://theory.cm.utexas.edu/bader/

    Requirements :
        * a ACF.dat file (bader output)
        * a POSCAR/CONTCAR file of the structure (read atom names).
        * a POTCAR file (read valence electron)

    """

    try:
        import pymatgen as mg
        from pymatgen.io.vaspio.vasp_input import Potcar
    except ImportError:
        _die("\n ## Pymatgen may be not available ##", 1)

    #
    # read atom names
    #
    if os.path.exists("POSCAR"):
        struct = mg.read_structure("POSCAR")
        atomNames = [el.symbol for el in struct.species]

    elif os.path.exists("CONTCAR"):
        struct = mg.read_structure("CONTCAR")
        atomNames = [el.symbol for el in struct.species]

    else:
        _die("ERROR: need a POSCAR/CONTCAR file to get atom names", 1)

    nat = len(atomNames)

    # 
    # read potcar
    #
    if os.path.exists("POTCAR"):
        potcar = Potcar.from_file("POTCAR")
    else:
        _die("ERROR: need a POTCAR file", 1)

    lines = ""

    #
    # System composition and valence electron
    #
    valence = dict()
    for singlePotcar in potcar:
        lines += "%3s     POTCAR : %10s     zval : %f\n" % \
            (singlePotcar.element, singlePotcar.symbol, singlePotcar.zval)
        valence[singlePotcar.element] = singlePotcar.zval

    #
    # read population from ACF.dat file
    #
    if os.path.exists("ACF.dat"):
        acf = open("ACF.dat", "r").read().split(80 * "-")[1].split("\n")[1:-1]
        population = [float(line.split()[4]) for line in acf]
        if len(population) != nat:
            _die("Error, number of atom in ACF.dat not consistent", 1)
    else:
        _die("ERROR: file ACF.dat not found", 1)

    #
    # output
    #
    lines += "\n   i  name   Z      pop       charge\n"
    lines += "------------------------------------\n"
    for iat in range(nat):
        charge = valence[atomNames[iat]] - population[iat]
        lines += "%4d %4s %4d %10.4f %10.4f\n" % (iat + 1, atomNames[iat], \
                valence[atomNames[iat]], population[iat], charge)
    lines += "------------------------------------\n"

    #
    # average charges
    #
    avePop = dict()
    av2Charge = dict()
    for el in struct.composition.elements:
        avePop[el.symbol] = 0.
        av2Charge[el.symbol] = 0.

    lines += "Composition : {0}\n".format(struct.composition.reduced_formula)

    for iat in range(nat):
        name = atomNames[iat]
        avePop[name] += population[iat]
        av2Charge[name] += (valence[name] - population[iat])**2

    lines += "Averages :\n"
    lines += " name   Z          charge\n"
    lines += "------------------------------------\n"
    for el in struct.composition.elements:
        nel = struct.composition[el.symbol]
        name = el.symbol
        avePop[name] /= nel
        charge  = valence[name] - avePop[name]

        av2Charge[name] /= nel
        if fabs(av2Charge[name] - charge**2) < 1e-5:
            av2Charge[name] = 0.
        else:
            av2Charge[name] = sqrt(av2Charge[name] - charge**2)

        lines += "%4s %4d %10.4f +/- %7.4f\n" % (name, valence[name], charge,\
                av2Charge[name])
    lines += "------------------------------------\n"

    if not filename:
        print(lines)
    else:
        open(filename, "w").write(lines)

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
# compute things
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

def chgsum():
    """ linear add of CHGCAR files """

    try:
        from pymatgen.io.vaspio.vasp_output import Chgcar
    except ImportError:
        _die("\n ## Pymatgen may be not available ##", 1)

    scale_factor = 1.

    # command line options
    if len(sys.argv) == 4:
        chgcar1 = sys.argv[2]
        chgcar2 = sys.argv[3]

    elif len(sys.argv) == 5:
        chgcar1 = sys.argv[2]
        chgcar2 = sys.argv[3]
        try:
            scale_factor = float(sys.argv[4])
        except ValueError:
            _die("Error, scale_factor must be a number", 1)
    else:
        _die("Error in arguemnts list. try {0} -h to get some \
            help".format(sys.argv[0]), 1)
        
    # ask if you agree the computation
    print("I will compute : {0} + {1}*{2}".format(chgcar1, scale_factor,\
        chgcar2))

    if not question("Do you agree ?"):
        _die()

    # files exist ?
    if not os.path.exists(chgcar1):
        _die("Error : File '{0}' does not exist !\n".format(chgcar1))

    if not os.path.exists(chgcar2):
        _die("Error : File '{0}' does not exist !\n".format(chgcar2))

    # sum densities
    print("Reading {0}".format(chgcar1))
    rho1 = Chgcar.from_file(chgcar1)
    print("Reading {0}".format(chgcar2))
    rho2 = Chgcar.from_file(chgcar2)
    rho_sum = rho1.linear_add(rho2, scale_factor)

    # name of output file
    print(dashedLine)
    if os.path.exists("CHGCAR_sum"):
        if not question("file CHGCAR_sum exists, overwrite it ?"):
            _die()
    print(" write sum density in : CHGCAR_sum\n" + dashedLine)
    rho_sum.write_file("CHGCAR_sum")

def get_deplacement(xmlfile="vasprun.xml", fs1=None, fs2=None):
    """ get displacement between two structures """

    import numpy as np
    try:
        from pymatgen.io.vaspio.vasp_output import Vasprun
        import pymatgen as mg
    except ImportError:
        _die("\n ## Pymatgen may be not available ##", 1)

    if xmlfile:
        if not os.path.exists(xmlfile):
            _die("ERROR, file %s does not exist" % xmlfile, 1)

        run = Vasprun(xmlfile)
        struct1 = run.initial_structure
        struct2 = run.final_structure

    elif fs1 and fs2:
        if not os.path.exists(fs1):
            _die("ERROR, file %s does not exist" % fs1, 1)
        if not os.path.exists(fs2):
            _die("ERROR, file %s does not exist" % fs2, 1)
        struct1 = mg.read_structure(fs1)
        struct2 = mg.read_structure(fs2)

        if len(struct1.sites) != len(struct2.sites):
            _die("ERROR, structures are unconsistant", 1)

    else:
        _die("ERROR, you must give two structures or an xml file", 1)

    print("Structure 1 : " + struct1.composition.reduced_formula)
    print("abc      : %10.4f %10.4f %10.4f" % struct1.lattice.abc)
    print("angles   : %10.4f %10.4f %10.4f" % struct1.lattice.angles)

    print("\nStructure 2 : " + struct2.composition.reduced_formula)
    print("abc      : %10.4f %10.4f %10.4f" % struct2.lattice.abc)
    print("angles   : %10.4f %10.4f %10.4f" % struct2.lattice.angles)

    # compute atoms displacement
    print("\n" + 75 * "-")
    print("   atome    positions initiales          positions finales       distance")
    print(75 * "-")
    iat = 0
    for site1, site2 in zip(struct1, struct2):
        iat += 1
        ligne = "%4d%4s" % (iat, site1.specie.symbol)
        for x in site1.coords:
            ligne += "%8.3f" % x

        ligne += "    "
        for x in site2.coords:
            ligne += "%8.3f" % x

        ligne += "    "
        d, j = site1.distance_and_image(site2)
        ligne += "%8.3f" % d
        if (j != np.zeros(3)).all():
            ligne += "(%2d,%2d,%2d)" % j.tuple

        print(ligne)

if __name__ == "__main__":
    check()
    select()

